// RUN: %empty-directory(%t)
// RUN: %swift -c -primary-file %s -enable-large-loadable-types -Xllvm -sil-print-after=loadable-address -sil-verify-all -o %t/big_types_constructors.o 2>&1 | %FileCheck %s

import Swift
import Builtin

public struct BigStruct {
  var i0 : Int32 = 0
  var i1 : Int32 = 1
  var i2 : Int32 = 2
  var i3 : Int32 = 3
  var i4 : Int32 = 4
  var i5 : Int32 = 5
  var i6 : Int32 = 6
  var i7 : Int32 = 7
  var i8 : Int32 = 8
}

public struct BigBigStruct {
  var s : BigStruct
}

public enum LargeTupleEnum {
  case Empty1
  case Empty2
  case Full((BigStruct, Int32))
}

public enum LargeEnum {
  case Empty1
  case Empty2
  case Full(BigStruct)
}

// CHECK-LABEL: sil @test_tuple : $@convention(thin) (@in_constant BigStruct) -> @out (BigStruct, Int32) {
// CHECK: bb0(%0 : $*(BigStruct, Int32), %1 : $*BigStruct):
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $(BigStruct, Int32)
// CHECK: [[INTLIT:%.*]] = integer_literal $Builtin.Int32, 42
// CHECK: [[INTLITSTRUCT:%.*]] = struct $Int32 ([[INTLIT]] : $Builtin.Int32)
// CHECK: [[TBIGADDR:%.*]] = tuple_element_addr [[ALLOCBIG]] : $*(BigStruct, Int32), 0
// CHECK: copy_addr [take] %1 to [initialization] [[TBIGADDR]] : $*BigStruct
// CHECK: [[TINTADDR:%.*]] = tuple_element_addr [[ALLOCBIG]] : $*(BigStruct, Int32), 1
// CHECK: store [[INTLITSTRUCT]] to [[TINTADDR]] : $*Int32
// CHECK: copy_addr [take] [[ALLOCBIG]] to [initialization] %0 : $*(BigStruct, Int32)
// CHECK: dealloc_stack [[ALLOCBIG]] : $*(BigStruct, Int32)
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'test_tuple'
sil @test_tuple : $@convention(thin) (BigStruct) -> (BigStruct, Int32) {
bb0(%0 : $BigStruct):
  %2 = integer_literal $Builtin.Int32, 42
  %3 = struct $Int32 (%2 : $Builtin.Int32)
  %4 = tuple (%0 : $BigStruct, %3 : $Int32)
  return %4 : $(BigStruct, Int32)
}

// CHECK-LABEL: sil hidden @construct_big_struct : $@convention(method) (@thin BigStruct.Type) -> @out BigStruct {
// CHECK: bb0(%0 : $*BigStruct, %1 : $@thin BigStruct.Type):
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $BigStruct
// CHECK: copy_addr [take] [[ALLOCBIG]] to [initialization] %0 : $*BigStruct
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'construct_big_struct'
sil hidden @construct_big_struct : $@convention(method) (@thin BigStruct.Type) -> BigStruct {
bb0(%0 : $@thin BigStruct.Type):
  %1 = alloc_stack $BigStruct, var, name "self"   // users: %36, %32, %28, %24, %20, %16, %12, %8, %4, %39
  %2 = integer_literal $Builtin.Int32, 0          // user: %3
  %3 = struct $Int32 (%2 : $Builtin.Int32)        // users: %38, %5
  %4 = struct_element_addr %1 : $*BigStruct, #BigStruct.i0 // user: %5
  store %3 to %4 : $*Int32                        // id: %5
  %6 = integer_literal $Builtin.Int32, 1          // user: %7
  %7 = struct $Int32 (%6 : $Builtin.Int32)        // users: %38, %9
  %8 = struct_element_addr %1 : $*BigStruct, #BigStruct.i1 // user: %9
  store %7 to %8 : $*Int32                        // id: %9
  %10 = integer_literal $Builtin.Int32, 2         // user: %11
  %11 = struct $Int32 (%10 : $Builtin.Int32)      // users: %38, %13
  %12 = struct_element_addr %1 : $*BigStruct, #BigStruct.i2 // user: %13
  store %11 to %12 : $*Int32                      // id: %13
  %14 = integer_literal $Builtin.Int32, 3         // user: %15
  %15 = struct $Int32 (%14 : $Builtin.Int32)      // users: %38, %17
  %16 = struct_element_addr %1 : $*BigStruct, #BigStruct.i3 // user: %17
  store %15 to %16 : $*Int32                      // id: %17
  %18 = integer_literal $Builtin.Int32, 4         // user: %19
  %19 = struct $Int32 (%18 : $Builtin.Int32)      // users: %38, %21
  %20 = struct_element_addr %1 : $*BigStruct, #BigStruct.i4 // user: %21
  store %19 to %20 : $*Int32                      // id: %21
  %22 = integer_literal $Builtin.Int32, 5         // user: %23
  %23 = struct $Int32 (%22 : $Builtin.Int32)      // users: %38, %25
  %24 = struct_element_addr %1 : $*BigStruct, #BigStruct.i5 // user: %25
  store %23 to %24 : $*Int32                      // id: %25
  %26 = integer_literal $Builtin.Int32, 6         // user: %27
  %27 = struct $Int32 (%26 : $Builtin.Int32)      // users: %38, %29
  %28 = struct_element_addr %1 : $*BigStruct, #BigStruct.i6 // user: %29
  store %27 to %28 : $*Int32                      // id: %29
  %30 = integer_literal $Builtin.Int32, 7         // user: %31
  %31 = struct $Int32 (%30 : $Builtin.Int32)      // users: %38, %33
  %32 = struct_element_addr %1 : $*BigStruct, #BigStruct.i7 // user: %33
  store %31 to %32 : $*Int32                      // id: %33
  %34 = integer_literal $Builtin.Int32, 8         // user: %35
  %35 = struct $Int32 (%34 : $Builtin.Int32)      // users: %38, %37
  %36 = struct_element_addr %1 : $*BigStruct, #BigStruct.i8 // user: %37
  store %35 to %36 : $*Int32                      // id: %37
  %38 = struct $BigStruct (%3 : $Int32, %7 : $Int32, %11 : $Int32, %15 : $Int32, %19 : $Int32, %23 : $Int32, %27 : $Int32, %31 : $Int32, %35 : $Int32) // user: %40
  dealloc_stack %1 : $*BigStruct                  // id: %39
  return %38 : $BigStruct                         // id: %40
} // end sil function '$construct_big_struct'

// CHECK-LABEL: sil @call_test_tuple : $@convention(thin) () -> () {
// CHECK: bb0:
// CHECK: [[ALLOCTUPLE:%.*]] = alloc_stack $(BigStruct, Int32)
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $BigStruct
// CHECK: [[FREF:%.*]] = function_ref @test_tuple : $@convention(thin) (@in_constant BigStruct) -> @out (BigStruct, Int32)
// CHECK: apply [[FREF]]([[ALLOCTUPLE]], [[ALLOCBIG]]) : $@convention(thin) (@in_constant BigStruct) -> @out (BigStruct, Int32)
// CHECK: [[LOADTUPLE:%.*]] = load [[ALLOCTUPLE]] : $*(BigStruct, Int32)
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'call_test_tuple'
sil @call_test_tuple : $@convention(thin) () -> () {
bb0:
  %0 = metatype $@thin BigStruct.Type
  // function_ref BigStruct.init()
  %1 = function_ref @construct_big_struct : $@convention(method) (@thin BigStruct.Type) -> BigStruct
  %2 = apply %1(%0) : $@convention(method) (@thin BigStruct.Type) -> BigStruct
  debug_value %2 : $BigStruct, let, name "b"
  // function_ref test_tuple(_:)
  %4 = function_ref @test_tuple : $@convention(thin) (BigStruct) -> (BigStruct, Int32)
  %5 = apply %4(%2) : $@convention(thin) (BigStruct) -> (BigStruct, Int32)
  %6 = tuple_extract %5 : $(BigStruct, Int32), 0
  %7 = tuple_extract %5 : $(BigStruct, Int32), 1
  %8 = tuple ()
  return %8 : $()
}

// CHECK-LABEL: sil @test_tuple_local_only : $@convention(thin) (@in_constant BigStruct) -> () {
// CHECK: bb0(%0 : $*BigStruct):
// CHECK: [[TBIGADDR:%.*]] = tuple_element_addr %{{.*}} : $*(BigStruct, Int32), 0
// CHECK-NEXT: copy_addr [take] %0 to [initialization] [[TBIGADDR]] : $*BigStruct
// CHECK: [[TBIGADDR:%.*]] = tuple_element_addr %{{.*}} : $*((BigStruct, Int32), Int32), 0
// CHECK-NEXT: copy_addr [take] %{{.*}} to [initialization] [[TBIGADDR]] : $*(BigStruct, Int32)
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'test_tuple_local_only'
sil @test_tuple_local_only : $@convention(thin) (BigStruct) -> () {
bb0(%0 : $BigStruct):
  %2 = integer_literal $Builtin.Int32, 42
  %3 = struct $Int32 (%2 : $Builtin.Int32)
  %4 = tuple (%0 : $BigStruct, %3 : $Int32)
  %5 = tuple (%4: $(BigStruct, Int32), %3 : $Int32)
  %rt = tuple ()
  return %rt : $()
}

// CHECK-LABEL: sil @test_struct_construction : $@convention(thin) (@in_constant BigStruct) -> @out BigBigStruct {
// CHECK: bb0(%0 : $*BigBigStruct, %1 : $*BigStruct):
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $BigBigStruct
// CHECK-NEXT: [[TBIGADDR:%.*]] = struct_element_addr [[ALLOCBIG]] : $*BigBigStruct, #BigBigStruct.s
// CHECK-NEXT: copy_addr [take] %1 to [initialization] [[TBIGADDR]] : $*BigStruct
// CHECK-NEXT: copy_addr [take] [[ALLOCBIG]] to [initialization] %0 : $*BigBigStruct
// CHECK-NEXT: dealloc_stack [[ALLOCBIG]] : $*BigBigStruct
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'test_struct_construction'
sil @test_struct_construction : $@convention(thin) (BigStruct) -> BigBigStruct {
bb0(%0 : $BigStruct):
  %bigStruct = struct $BigBigStruct (%0 : $BigStruct)
  return %bigStruct : $BigBigStruct
}

// CHECK-LABEL: sil @test_tuple_try_apply : $@convention(thin) (@in_guaranteed Int32, @noescape @callee_guaranteed (@guaranteed Int32) -> (@out Optional<(BigStruct, Int32)>, @error Error)) -> (@out Optional<(BigStruct, Int32)>, @error Error) {
// CHECK: bb0(%0 : $*Optional<(BigStruct, Int32)>, %1 : $*Int32, %2 : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@out Optional<(BigStruct, Int32)>, @error Error)):
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $Optional<(BigStruct, Int32)>
// CHECK: try_apply %2([[ALLOCBIG]], %{{.*}}) : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@out Optional<(BigStruct, Int32)>, @error Error), normal bb1, error bb2
// CHECK: bb1(%6 : $()):
// CHECK: copy_addr [take] [[ALLOCBIG]] to [initialization] %0 : $*Optional<(BigStruct, Int32)>
// CHECK: return %{{.*}} : $()
// CHECK: bb2(%{{.*}} : $Error):
// CHECK: throw %{{.*}} : $Error
// CHECK-LABEL: } // end sil function 'test_tuple_try_apply'
sil @test_tuple_try_apply : $@convention(thin) (@in_guaranteed Int32, @noescape @callee_guaranteed (@guaranteed Int32) -> (@owned Optional<(BigStruct, Int32)>, @error Error)) -> (@out Optional<(BigStruct, Int32)>, @error Error) {
bb0(%0 : $*Optional<(BigStruct, Int32)>, %1 : $*Int32, %2 : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@owned Optional<(BigStruct, Int32)>, @error Error)):
  %3 = load %1 : $*Int32
  try_apply %2(%3) : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@owned Optional<(BigStruct, Int32)>, @error Error), normal bb1, error bb2

bb1(%5 : $Optional<(BigStruct, Int32)>):
  store %5 to %0 : $*Optional<(BigStruct, Int32)>
  %7 = tuple ()
  return %7 : $()

bb2(%9 : $Error):
  %10 = builtin "willThrow"(%9 : $Error) : $()
  throw %9 : $Error
}

// CHECK-LABEL: sil @test_enum_tuple_try_apply : $@convention(thin) (@in_guaranteed Int32, @noescape @callee_guaranteed (@guaranteed Int32) -> (@out LargeTupleEnum, @error Error)) -> (@out Optional<(BigStruct, Int32)>, @error Error) {
// CHECK: bb0(%0 : $*Optional<(BigStruct, Int32)>, %1 : $*Int32, %2 : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@out LargeTupleEnum, @error Error)):
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $LargeTupleEnum
// CHECK: try_apply %2([[ALLOCBIG]], %{{.*}}) : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@out LargeTupleEnum, @error Error), normal bb1, error bb2
// CHECK: bb1(%6 : $()):
// CHECK: return %{{.*}} : $()
// CHECK: bb2(%{{.*}} : $Error):
// CHECK: throw %{{.*}} : $Error
// CHECK-LABEL: } // end sil function 'test_enum_tuple_try_apply'
sil @test_enum_tuple_try_apply : $@convention(thin) (@in_guaranteed Int32, @noescape @callee_guaranteed (@guaranteed Int32) -> (@owned LargeTupleEnum, @error Error)) -> (@out Optional<(BigStruct, Int32)>, @error Error) {
bb0(%0 : $*Optional<(BigStruct, Int32)>, %1 : $*Int32, %2 : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@owned LargeTupleEnum, @error Error)):
  %3 = load %1 : $*Int32
  try_apply %2(%3) : $@noescape @callee_guaranteed (@guaranteed Int32) -> (@owned LargeTupleEnum, @error Error), normal bb1, error bb2

bb1(%5 : $LargeTupleEnum):
  %7 = tuple ()
  return %7 : $()

bb2(%9 : $Error):
  %10 = builtin "willThrow"(%9 : $Error) : $()
  throw %9 : $Error
}

// CHECK-LABEL: sil @test_enum : $@convention(thin) (@in_constant LargeEnum) -> @out LargeEnum {
// CHECK: bb0(%0 : $*LargeEnum, %1 : $*LargeEnum):
// CHECK: switch_enum_addr %{{.*}} : $*LargeEnum, case #LargeEnum.Empty1!enumelt: bb1, case #LargeEnum.Empty2!enumelt: bb2, case #LargeEnum.Full!enumelt.1: bb3
// CHECK: bb3:
// CHECK: unchecked_take_enum_data_addr %{{.*}} : $*LargeEnum, #LargeEnum.Full!enumelt.1
// CHECK: [[ENUMDADDR:%.*]] = init_enum_data_addr %{{.*}} : $*LargeEnum, #LargeEnum.Full!enumelt.1
// CHECK: copy_addr [take] %{{.*}} to [initialization] [[ENUMDADDR]] : $*BigStruct
// CHECK: copy_addr [take] %{{.*}} to [initialization] %0 : $*LargeEnum
// CHECK-LABEL: } // end sil function 'test_enum'
sil @test_enum : $@convention(thin) (LargeEnum) -> LargeEnum {
// %0                                             // users: %2, %1
bb0(%0 : $LargeEnum):
  debug_value %0 : $LargeEnum, let, name "x", argno 1 // id: %1
  switch_enum %0 : $LargeEnum, case #LargeEnum.Empty1!enumelt: bb1, case #LargeEnum.Empty2!enumelt: bb2, case #LargeEnum.Full!enumelt.1: bb3 // id: %2

bb1:                                              // Preds: bb0
  unreachable                                     // id: %3

bb2:                                              // Preds: bb0
  unreachable                                     // id: %4

// %5                                             // users: %8, %6
bb3(%5 : $BigStruct):                             // Preds: bb0
  debug_value %5 : $BigStruct, let, name "payload" // id: %6
  %7 = metatype $@thin LargeEnum.Type
  %8 = enum $LargeEnum, #LargeEnum.Full!enumelt.1, %5 : $BigStruct // user: %9
  return %8 : $LargeEnum                          // id: %9
} // end sil function 'test_enum'

// CHECK-LABEL: sil @call_test_enum_full : $@convention(thin) () -> () {
// CHECK: bb0:
// CHECK: [[ALLOCBIG:%.*]] = alloc_stack $BigStruct
// CHECK: [[FREFSTRUCT:%.*]] = function_ref @construct_big_struct : $@convention(method) (@thin BigStruct.Type) -> @out BigStruct
// CHECK: apply [[FREFSTRUCT:%.*]]([[ALLOCBIG]], %{{.*}}) : $@convention(method) (@thin BigStruct.Type) -> @out BigStruct
// CHECK: [[ENUMDADDR:%.*]] = init_enum_data_addr %{{.*}} : $*LargeEnum, #LargeEnum.Full!enumelt.1
// CHECK: copy_addr [take] [[ALLOCBIG]] to [initialization] [[ENUMDADDR]] : $*BigStruct
// CHECK: [[FREFENUM:%.*]] = function_ref @test_enum : $@convention(thin) (@in_constant LargeEnum) -> @out LargeEnum
// CHECK: apply [[FREFENUM]]
// CHECK-LABEL: } // end sil function 'call_test_enum_full'
sil @call_test_enum_full : $@convention(thin) () -> () {
bb0:
  %0 = metatype $@thin LargeEnum.Type
  %1 = metatype $@thin BigStruct.Type             // user: %3
  // function_ref BigStruct.init()
  %2 = function_ref @construct_big_struct : $@convention(method) (@thin BigStruct.Type) -> BigStruct
  %3 = apply %2(%1) : $@convention(method) (@thin BigStruct.Type) -> BigStruct
  %4 = enum $LargeEnum, #LargeEnum.Full!enumelt.1, %3 : $BigStruct // users: %7, %5
  debug_value %4 : $LargeEnum, let, name "b"      // id: %5
  // function_ref test_enum(_:)
  %6 = function_ref @test_enum : $@convention(thin) (LargeEnum) -> LargeEnum // user: %7
  %7 = apply %6(%4) : $@convention(thin) (LargeEnum) -> LargeEnum
  %8 = tuple ()                                   // user: %9
  return %8 : $()                                 // id: %9
}
